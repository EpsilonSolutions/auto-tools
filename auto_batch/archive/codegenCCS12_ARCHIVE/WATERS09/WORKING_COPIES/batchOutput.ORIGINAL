Final batch eq: (e(mpk#2?,(prod{z := 0,N} on sig1_z^(s_z * delta_z))) * (e(mpk#5?,(prod{z := 0,N} on sig2_z^(s1_z * delta_z))) * (e(mpk#3?,(prod{z := 0,N} on sig3_z^(s1_z * delta_z))) * (e(mpk#6?,(prod{z := 0,N} on sig4_z^(s2_z * delta_z))) * e(mpk#4?,(prod{z := 0,N} on sig5_z^(s2_z * delta_z))))))) == (e((mpk#7? * mpk#8?),(prod{z := 0,N} on sig6_z^(s1_z * (s2_z * delta_z)))) * (e(((mpk#9? * (mpk#10? * mpk#13?)) * ((mpk#11? * mpk#13?) * mpk#14?)),(prod{z := 0,N} on sig7_z^(s1_z * (delta_z * (s2_z * (-t_z * (M_z * (tagc_z * (t_z * theta_z))))))))) * (e(mpk#0?,(prod{z := 0,N} on sigK_z^(t_z * (-theta_z * -delta_z)))) * A^sum{z := 0,N} of (s2_z * delta_z))))
<====	PREP FOR CODE GEN	====>

Final version => (e(mpk#2?,dotA) * (e(mpk#5?,dotB) * (e(mpk#3?,dotC) * (e(mpk#6?,dotD) * e(mpk#4?,dotE))))) == (e((mpk#7? * mpk#8?),dotF) * (e(((mpk#9? * (mpk#10? * mpk#13?)) * ((mpk#11? * mpk#13?) * mpk#14?)),dotG) * (e(mpk#0?,dotH) * A^sumI))) 

Compute:  dotA := (prod{z := 0,N} on sig1_z^(s_z * delta_z))
Compute:  dotB := (prod{z := 0,N} on sig2_z^(s1_z * delta_z))
Compute:  dotC := (prod{z := 0,N} on sig3_z^(s1_z * delta_z))
Compute:  dotD := (prod{z := 0,N} on sig4_z^(s2_z * delta_z))
Compute:  dotE := (prod{z := 0,N} on sig5_z^(s2_z * delta_z))
Compute:  dotF := (prod{z := 0,N} on sig6_z^(s1_z * (s2_z * delta_z)))
Compute:  dotG := (prod{z := 0,N} on sig7_z^(s1_z * (delta_z * (s2_z * (-t_z * (M_z * (tagc_z * (t_z * theta_z))))))))
Compute:  dotH := (prod{z := 0,N} on sigK_z^(t_z * (-theta_z * -delta_z)))
Compute:  sumI := (sum{z := 0,N} of (s2_z * delta_z))
Precompute: s1_z := random(ZR)
Precompute: theta_z := (tagc - tagk)^-1
Precompute: s_z := (s1 + s2)
Precompute: s2_z := random(ZR)
Precompute: delta := for{z := 1, N} do prng_z
Precompute: t_z := random(ZR)
Precompute: tagc_z := random(ZR)
Precompute: A := junkjunk
dotA := G2
dotB := G2
dotC := G2
dotD := G2
dotE := G2
dotF := G2
dotG := G2
dotH := G2
sumI := ZR
