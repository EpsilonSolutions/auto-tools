name := hw
N := 100
setting := asymmetric

BEGIN :: types
 m := Str
 n := ZR
 i := Int
END :: types

BEGIN :: func:setup
input := None
 g1 := random(G1)
 g2 := random(G2)
output := list{g1, g2}
END :: func:setup

BEGIN :: func:keygen
input := list{g1, g2} 
 a := random(ZR)
 A := g2^a
 u := random(G1)
 v := random(G1)
 d := random(G1)
 U := e(u, A)
 V := e(v, A)
 D := e(d, A)
 w := random(ZR)
 z := random(ZR)
 h := random(ZR)
 w1 := g1 ^ w
 w2 := g2 ^ w
 z1 := g1 ^ z
 z2 := g2 ^ z
 h1 := g1 ^ h
 h2 := g2 ^ h
 i := 0
 pk := list{U, V, D}
 spk := list{g1, w1, z1, h1, u, v, d} 
 vpk := list{g2, w2, z2, h2}
 sk := a
output := list{i, pk, sk}
END :: func:keygen

BEGIN :: func:sign
input := list{spk, sk, i, m}
 spk := expand{g1, w1, z1, h1, u, v, d}
 i := i + 1
 M := H(m, ZR)
 r := random(ZR)
 t := random(ZR)
 n := ceillog(2, i)
 sig1:= (((u^M)*(v^r)*d)^sk)*((w1^n)*(z1^i)*h1)^t
 sig2 := g1 ^ t
sig := list{sig1, sig2, r, i}
output := sig
END :: func:sign


BEGIN :: func:verify
input := list{pk, g2, w2, z2, h2, m, sig}
 pk := expand{U, V, D}
 sig := expand{sig1, sig2, r, i}

 M := H(m, ZR)
 n := ceillog(2, i)

BEGIN :: if
 if { e(sig1, g2) == ((U^M) * (V^r) * D * e(sig2, ((w2^n)*((z2^i)*h2)))) }
    output := True
 else
    output := False
END :: if
END :: func:verify

constant := list{g2, w2, z2, h2}
public := pk
signature := sig 
message := M

BEGIN :: precompute
 M := H(m, ZR)
 n := ceillog(2, i)
END :: precompute

# single signer
BEGIN :: count
message_count := N
public_count := one
signature_count := N
END :: count

verify := { e(sig1, g2) == ((U^M) * (V^r) * D * e(sig2, ((w2^n)*((z2^i)*h2)))) }
