name := sw05
setting := asymmetric

N := 2
secparam := 80

BEGIN :: types
evalTVar := G2
M := GT
S := list
DBlinded := list
blindingFactorDBlinded := list
transformOutputList := list
END :: types

BEGIN :: func:setup
input := list{n, d}
g := random(G1)
y := random(ZR)
g1 := g ^ y
g2 := random(G2)

BEGIN :: for
for{i := 0, n+1}
t#i := random(G2)
END :: for
        
dummyVar := random(ZR)

pk := list{g, g1, g2, t}
mk := list{y, dummyVar}
output := list{pk, mk}
END :: func:setup        

BEGIN :: func:evalT
input := list{pk, n, x}
t := pk#3
BEGIN :: for
for{i := 0, n+1}
N#i := init(ZR,i+1)
Nint#i := i + 1
END :: for

coeffs := recoverCoefficientsDict(N)
prodResult := init(G2)
lenNint := len(Nint)
BEGIN :: for
for{i := 0, lenNint}
loopVar := Nint#i
j := init(ZR, loopVar)
loopVarMinusOne := loopVar - 1
prodResult := prodResult * (t#loopVarMinusOne ^ coeffs#j)
END :: for

T := (pk#2 ^ (x * n)) * prodResult
output := T
END :: func:evalT

BEGIN :: func:intersectionSubset
input := list{w, wPrime, d}
wLen := len(w)
wPrimeLen := len(wPrime)
SIndex := 0
BEGIN :: for
for{i := 0, wLen}
BEGIN :: forinner
forinner{j := 0, wPrimeLen}
BEGIN :: if
if {w#i == wPrime#j}
S#SIndex := w#i
SIndex := SIndex + 1
END :: if
END :: forinner
END :: for

BEGIN :: for
for{k := 0, d}
SSub#k := S#k
END :: for
       
output := SSub
END :: func:intersectionSubset

BEGIN :: func:extract
input := list{mk, ID, pk, dOver, n}
blindingFactor0Blinded := random(ZR)
zz := random(ZR)
lenID := len(ID)
BEGIN :: for
for{i := 0, lenID}
loopVar := ID#i
wHash#i := H(loopVar, ZR)
END :: for

wHashBlinded := wHash
r := random(ZR)

BEGIN :: for
for{i := 0,dOver}
q#i := random(ZR)
END :: for

q#0 := mk#0
shares := genShares(mk#0, dOver, n, q, wHash)

wHashLen := len(wHash)
BEGIN :: for
for{i := 0,wHashLen}
loopVar := wHash#i
evalTVar := evalT(pk, n, loopVar)
D#loopVar := ((pk#2^shares#i#1) * (evalTVar^r))
d#loopVar := (pk#0^r)
END :: for

dBlinded := d
yLength := len(D)
DKeysSuffix := keys(D)
BEGIN :: for
for{y := 0,yLength}
DKeyLoopVar := DKeysSuffix#y
blindingFactorDBlinded#y := blindingFactor0Blinded
DBlinded#DKeyLoopVar := (D#DKeyLoopVar^(1 / blindingFactorDBlinded#y))
END :: for
sk := list{wHashBlinded, DBlinded, dBlinded}
skBlinded := list{wHashBlinded, DBlinded, dBlinded}
output := list{blindingFactor0Blinded, blindingFactorDBlinded, skBlinded}
END :: func:extract

BEGIN :: func:encrypt
input := list{pk, wPrime, M, n}
wPrimeLen := len(wPrime)
BEGIN :: for
for{i := 0, wPrimeLen}
loopVar := wPrime#i
wPrimeHash#i := H(loopVar, ZR)
END :: for

s := random(ZR)

Eprime := M * (e(pk#1, pk#2) ^ s)
Eprimeprime := pk#0 ^ s

wPrimeHashLen := len(wPrimeHash)
BEGIN :: for
for{i := 0, wPrimeHashLen}
loopVar := wPrimeHash#i
evalTVar := evalT(pk, n, loopVar)
E#loopVar := evalTVar ^ s
END :: for
        
CT := list{wPrimeHash, Eprime, Eprimeprime, E}
output := CT
END :: func:encrypt

BEGIN :: func:transform
input := list{pk, sk, CT, dInputParam}
CT := expand{wPrimeHash, Eprime, Eprimeprime, E}
sk := expand{wHash, D, d}
transformOutputList#0 := intersectionSubset(wHash, wPrimeHash, dInputParam)
S := transformOutputList#0
transformOutputList#1 := recoverCoefficientsDict(S)
coeffs := transformOutputList#1
transformOutputList#2 := len(S)
SLen := transformOutputList#2
BEGIN :: for
for{i := 0,SLen}
transformOutputList#1000+5*i? := S#i
loopVar := transformOutputList#1000+5*i?
transformOutputList#1001+5*i? := e((d#loopVar^coeffs#loopVar),E#loopVar)
loopPairings := transformOutputList#1001+5*i?
transformOutputList#1002+5*i? := e((Eprimeprime^-coeffs#loopVar),D#loopVar)
loopPairings := transformOutputList#1002+5*i?
END :: for
BEGIN :: for
for{y := 0,SLen}
transformOutputList#2000+4*y? := S#y
loopVar := transformOutputList#2000+4*y?
transformOutputList#2001+4*y? := e((Eprimeprime^coeffs#loopVar),D#loopVar)
loopPairings := transformOutputList#2001+4*y?
END :: for
output := transformOutputList
END :: func:transform

BEGIN :: func:decout
input := list{pk, sk, CT, dInputParam, transformOutputList, blindingFactor0Blinded, blindingFactorDBlinded}
CT := expand{wPrimeHash, Eprime, Eprimeprime, E}
sk := expand{wHash, D, d}
S := transformOutputList#0
coeffs := transformOutputList#1
prod := init(GT)
SLen := transformOutputList#2
BEGIN :: for
for{i := 0,SLen}
loopVar := transformOutputList#1000+5*i?
loopPairings := (transformOutputList#1001+5*i?)  * (transformOutputList#1002+5*i? ^ (blindingFactorDBlinded#i) ) 
prod := (prod * loopPairings)
END :: for
BEGIN :: for
for{y := 0,SLen}
loopVar := transformOutputList#2000+4*y?
loopPairings := (transformOutputList#2001+4*y? ^ (blindingFactorDBlinded#y) ) 
prod := (prod * loopPairings)
END :: for
M := (Eprime * prod)
output := M
END :: func:decout

